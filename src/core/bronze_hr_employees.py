"""Bronze layer data extraction.

This file was generated by `polster add-asset`. Implement your extract() function
to process data and write it to the bronze layer.
"""

from __future__ import annotations

from datetime import datetime

import polars as pl

try:
    # Try relative imports (when run as module through Dagster)
    from .storage import write_parquet
except ImportError:
    # Fall back to absolute imports (when run directly)
    import sys
    import os

    # Add src directory to path for absolute imports
    sys.path.insert(0, os.path.join(os.path.dirname(__file__), ".."))
    from core.storage import write_parquet


def extract() -> tuple[str, pl.DataFrame, dict]:
    """Bronze HR Employees Table Generator 
    Employee master data from HR system (SAP SuccessFactors)


    Returns:
        tuple[str, pl.DataFrame, dict]: Tuple containing:
            - Path to the written parquet file
            - DataFrame with extracted data
            - Metadata dictionary with row count, columns, etc.
    """
    
    import polars as pl
    from faker import Faker
    import random
    from datetime import datetime, timedelta
    from uuid import uuid4

    fake = Faker('nl_NL')
    Faker.seed(42)
    random.seed(42)

    # Constants
    DEPARTMENTS = ['HR', 'Finance', 'Supply_Chain', 'Production', 'Quality', 'Sales', 'IT', 'Marketing', 'CRM']
    JOB_LEVELS = ['junior', 'medior', 'senior', 'lead', 'manager', 'director']
    EMPLOYMENT_STATUSES = ['active', 'terminated', 'on_leave', 'retired']
    CONTRACT_TYPES = ['permanent', 'temporary', 'contract']
    SALARY_BANDS = ['A', 'B', 'C', 'D', 'E', 'F']
    LOCATIONS = ['Amersfoort', 'Wageningen', 'Beilen', 'Workum', 'Borculo', 'Lochem']
    NATIONALITIES = ['Dutch', 'Belgian', 'German', 'Polish', 'Romanian', 'Other']
    
    def generate_bronze_hr_employees(num_records=5000):
        """Generate employee master data with cross-department references"""
        data = []
        
        # Generate manager IDs first (managers are employees too)
        employee_ids = [str(uuid4())[:8] for _ in range(num_records)]
        
        for i in range(num_records):
            employee_id = employee_ids[i]
            hire_date = fake.date_between(start_date='-10y', end_date='today')
            
            # 10% chance of being terminated/on_leave/retired
            status = random.choices(
                EMPLOYMENT_STATUSES, 
                weights=[85, 5, 5, 5]
            )[0]
            
            termination_date = None
            if status in ['terminated', 'retired']:
                termination_date = fake.date_between(start_date=hire_date, end_date='today')
            elif status == 'on_leave':
                pass  # No termination date for on_leave
            
            # Manager assignment - senior roles manage others
            job_level = random.choice(JOB_LEVELS)
            if job_level in ['lead', 'manager', 'director'] and i > 10:
                manager_id = random.choice(employee_ids[:i])  # Earlier employees as managers
            else:
                manager_id = None
            
            # Assign department and location
            department = random.choice(DEPARTMENTS)
            location = random.choice(LOCATIONS)
            
            # Job title based on department and level
            job_titles = {
                'HR': ['HR Assistant', 'HR Coordinator', 'HR Business Partner', 'HR Manager', 'HR Director'],
                'Finance': ['Accountant', 'Financial Analyst', 'Controller', 'Finance Manager', 'CFO'],
                'Supply_Chain': ['Logistics Coordinator', 'Supply Chain Analyst', 'Warehouse Supervisor', 'Supply Chain Manager', 'Operations Director'],
                'Production': ['Production Worker', 'Machine Operator', 'Shift Supervisor', 'Production Manager', 'Plant Director'],
                'Quality': ['Quality Inspector', 'Quality Technician', 'Quality Engineer', 'Quality Manager', 'Quality Director'],
                'Sales': ['Sales Representative', 'Account Manager', 'Sales Supervisor', 'Sales Manager', 'Sales Director'],
                'IT': ['IT Support', 'Developer', 'System Analyst', 'IT Manager', 'CTO'],
                'Marketing': ['Marketing Coordinator', 'Campaign Manager', 'Brand Specialist', 'Marketing Manager', 'CMO'],
                'CRM': ['CRM Specialist', 'Customer Success Manager', 'Sales Operations', 'CRM Manager', 'VP Customer Success']
            }
            job_title = random.choice(job_titles.get(department, ['Employee']))
            
            record = {
                'employee_id': employee_id,
                'employee_number': f"EMP-{random.randint(10000, 99999)}",
                'first_name': fake.first_name(),
                'last_name': fake.last_name(),
                'email': fake.email(),
                'phone': fake.phone_number(),
                'date_of_birth': fake.date_of_birth(minimum_age=18, maximum_age=65),
                'hire_date': hire_date,
                'termination_date': termination_date,
                'employment_status': status,
                'job_title': job_title,
                'job_level': job_level,
                'department': department,
                'cost_center': f"CC-{random.randint(100, 999)}",
                'location': location,
                'manager_id': manager_id,
                'salary_band': random.choice(SALARY_BANDS),
                'contract_type': random.choice(CONTRACT_TYPES),
                'fte': random.choice([0.5, 0.6, 0.8, 0.9, 1.0]),
                'nationality': random.choices(NATIONALITIES, weights=[85, 3, 3, 3, 3, 3])[0],
                'created_at': datetime.now(),
                'updated_at': datetime.now()
            }
            data.append(record)
        
        return pl.DataFrame(data)
    
    df = generate_bronze_hr_employees(5000)
    # Add metadata
    df = df.with_columns(
        pl.lit(datetime.utcnow().isoformat()).alias("fetched_at")
    )
    
    # Write with timestamp
    timestamp = datetime.utcnow().strftime("%Y%m%dT%H%M%SZ")
    output_path = write_parquet(df, "bronze", f"bronze_hr_employees_{timestamp}.parquet")
    
    # Prepare metadata for Dagster
    metadata = {
        "row_count": len(df),
        "columns": list(df.columns),
        "dtypes": {col: str(dtype) for col, dtype in zip(df.columns, df.dtypes)},
    }
    
    return output_path, df, metadata

if __name__ == "__main__":
    extract()
